# Reglas del Proyecto AIRobot

## Stack Técnico
- **Framework**: Laravel 12 + PHP 8.x
- **Frontend**: Inertia + React + Tailwind + componentes propios + shadcn/ui
- **Base de datos**: SQLite (desarrollo)

## Arquitectura (SIEMPRE respetar)

### Capas y Responsabilidades

#### Controllers (`App\Http\Controllers`)
- **Delgados**: solo orquestan, NO contienen lógica de negocio
- Reciben Request, invocan Service, retornan Resource
- Estructura típica:
```php
public function store(StoreLeadRequest $request)
{
    $lead = $this->leadService->create($request->validated());
    return new LeadResource($lead);
}
```

#### Services (`App\Services`)
- **Única fuente de lógica de negocio**
- Dependen SIEMPRE de interfaces de Repositories
- Un Service por agregado/dominio (LeadService, CampaignService, etc.)
- Nunca acceden directamente a Eloquent
- Encapsulan llamadas HTTP/externas

#### Repositories
- **Interfaces**: `App\Repositories\Interfaces` (ej: `LeadRepositoryInterface`)
- **Implementaciones**: `App\Repositories\Eloquent` (ej: `EloquentLeadRepository`)
- Único punto de acceso a datos/modelos
- Binding en `RepositoryServiceProvider`

#### FormRequests (`App\Http\Requests`)
- Validación de entrada
- Reglas de autorización
- Preparación de datos (`prepareForValidation`)

#### Resources (`App\Http\Resources`)
- Formateo de respuestas JSON
- Transformación de modelos para API
- Ocultan campos sensibles

#### Enums (`App\Enums`)
- Estados y tipos (evitar strings mágicos)
- Backed enums con valores string/int
- Métodos helpers cuando sea necesario

#### Models (`App\Models`)
- Definición de schema (casts, fillable, relations)
- NO contienen lógica de negocio
- Relaciones Eloquent
- Accessors/Mutators solo para formateo básico

## Principios SOLID

### Single Responsibility
- Cada clase tiene UNA responsabilidad clara
- Service por agregado
- Repository por modelo
- Controller por recurso

### Dependency Inversion
- Services dependen de interfaces, NUNCA de implementaciones concretas
- Constructor injection para dependencias
- Binding en ServiceProviders

### Open/Closed
- Extensible mediante interfaces/estrategias
- No modificar código existente para agregar funcionalidad nueva

## Reglas de Implementación

### Al agregar nuevos features
1. ✅ Crear migración para cambios de schema
2. ✅ Actualizar/crear Model con relaciones y casts
3. ✅ Crear/actualizar Repository (interface + implementación)
4. ✅ Crear/actualizar Service con lógica de negocio
5. ✅ Crear FormRequest para validación
6. ✅ Crear/actualizar Controller (delgado)
7. ✅ Crear/actualizar Resource para respuestas
8. ✅ Registrar bindings si es necesario
9. ✅ Agregar rutas en `routes/api.php` o `routes/web.php`

### Nomenclatura
- **Código**: inglés (clases, métodos, variables)
- **UI/Mensajes**: español
- **Base de datos**: snake_case en inglés
- **Clases**: PascalCase
- **Métodos**: camelCase

### Prohibiciones
❌ Lógica de negocio en Controllers
❌ Acceso directo a Eloquent desde Controllers
❌ Dependencias de implementaciones concretas en Services
❌ Strings mágicos (usar Enums)
❌ Llamadas HTTP directas en Controllers
❌ Mezclar responsabilidades entre capas

### Testing
- Feature tests para flujos completos
- Unit tests para Services y lógica compleja
- Mocks de Repositories en tests de Services

### Comentarios
- Decisiones importantes justificadas en comentarios
- PHPDoc para métodos públicos con tipos y descripciones
- Evitar comentarios obvios

## Estructura de Carpetas

```
app/
├── Console/Commands/        # Comandos Artisan
├── Contracts/              # Interfaces globales
├── DTOs/                   # Data Transfer Objects
├── Enums/                  # Estados y tipos
├── Events/                 # Eventos del sistema
├── Exceptions/             # Excepciones personalizadas
├── Helpers/                # Funciones helper
├── Http/
│   ├── Controllers/        # Orquestación
│   ├── Middleware/         # Middleware HTTP
│   ├── Requests/           # Validación
│   └── Resources/          # Respuestas JSON
├── Jobs/                   # Jobs de queue
├── Listeners/              # Event listeners
├── Models/                 # Modelos Eloquent
├── Providers/              # Service Providers
├── Repositories/
│   ├── Interfaces/         # Contratos
│   └── Eloquent/          # Implementaciones
└── Services/               # Lógica de negocio
```

## Ejemplos de Patrones

### Service típico
```php
class LeadService
{
    public function __construct(
        private LeadRepositoryInterface $leadRepository,
        private CampaignRepositoryInterface $campaignRepository
    ) {}

    public function create(array $data): Lead
    {
        // Validar lógica de negocio
        $campaign = $this->campaignRepository->findOrFail($data['campaign_id']);
        
        // Crear lead
        $lead = $this->leadRepository->create($data);
        
        // Disparar eventos si es necesario
        event(new LeadCreated($lead));
        
        return $lead;
    }
}
```

### Repository típico
```php
// Interface
interface LeadRepositoryInterface extends BaseRepositoryInterface
{
    public function findByPhone(string $phone): ?Lead;
    public function getLeadsForCampaign(int $campaignId): Collection;
}

// Implementación
class EloquentLeadRepository extends BaseRepository implements LeadRepositoryInterface
{
    public function model(): string
    {
        return Lead::class;
    }

    public function findByPhone(string $phone): ?Lead
    {
        return $this->model->where('phone', $phone)->first();
    }
}
```

### Controller típico
```php
class LeadController extends Controller
{
    public function __construct(
        private LeadService $leadService
    ) {}

    public function store(StoreLeadRequest $request)
    {
        $lead = $this->leadService->create($request->validated());
        return new LeadResource($lead);
    }

    public function index(IndexLeadRequest $request)
    {
        $leads = $this->leadService->getAll($request->validated());
        return LeadResource::collection($leads);
    }
}
```

## Notas Adicionales

- No usar DDD complejo, mantener estructura clásica de Laravel con capas claras
- Jobs para procesos asíncronos (webhooks, emails, etc.)
- Events/Listeners para desacoplar acciones secundarias
- DTOs opcionales para transferencia de datos complejos entre capas
- Usar transacciones DB cuando sea necesario en Services

